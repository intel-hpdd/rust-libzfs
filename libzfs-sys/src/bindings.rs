/* automatically generated by rust-bindgen */

pub const ZFS_MAX_DATASET_NAME_LEN: ::std::os::raw::c_uint = 256;
pub const ZPROP_VALUE: &'static [u8; 6usize] = b"value\x00";
pub const ZPOOL_CONFIG_POOL_NAME: &'static [u8; 5usize] = b"name\x00";
pub const ZPOOL_CONFIG_VDEV_TREE: &'static [u8; 10usize] = b"vdev_tree\x00";
pub const ZPOOL_CONFIG_TYPE: &'static [u8; 5usize] = b"type\x00";
pub const ZPOOL_CONFIG_CHILDREN: &'static [u8; 9usize] = b"children\x00";
pub const ZPOOL_CONFIG_GUID: &'static [u8; 5usize] = b"guid\x00";
pub const ZPOOL_CONFIG_PATH: &'static [u8; 5usize] = b"path\x00";
pub const ZPOOL_CONFIG_DEVID: &'static [u8; 6usize] = b"devid\x00";
pub const ZPOOL_CONFIG_VDEV_STATS: &'static [u8; 11usize] = b"vdev_stats\x00";
pub const ZPOOL_CONFIG_WHOLE_DISK: &'static [u8; 11usize] = b"whole_disk\x00";
pub const ZPOOL_CONFIG_SPARES: &'static [u8; 7usize] = b"spares\x00";
pub const ZPOOL_CONFIG_HOSTID: &'static [u8; 7usize] = b"hostid\x00";
pub const ZPOOL_CONFIG_HOSTNAME: &'static [u8; 9usize] = b"hostname\x00";
pub const ZPOOL_CONFIG_PHYS_PATH: &'static [u8; 10usize] = b"phys_path\x00";
pub const ZPOOL_CONFIG_IS_LOG: &'static [u8; 7usize] = b"is_log\x00";
pub const ZPOOL_CONFIG_L2CACHE: &'static [u8; 8usize] = b"l2cache\x00";
pub const ZPOOL_CONFIG_AUX_STATE: &'static [u8; 10usize] = b"aux_state\x00";
pub const VDEV_TYPE_ROOT: &'static [u8; 5usize] = b"root\x00";
pub const VDEV_TYPE_MIRROR: &'static [u8; 7usize] = b"mirror\x00";
pub const VDEV_TYPE_REPLACING: &'static [u8; 10usize] = b"replacing\x00";
pub const VDEV_TYPE_RAIDZ: &'static [u8; 6usize] = b"raidz\x00";
pub const VDEV_TYPE_DISK: &'static [u8; 5usize] = b"disk\x00";
pub const VDEV_TYPE_FILE: &'static [u8; 5usize] = b"file\x00";
pub const VDEV_TYPE_MISSING: &'static [u8; 8usize] = b"missing\x00";
pub const VDEV_TYPE_HOLE: &'static [u8; 5usize] = b"hole\x00";
pub const VDEV_TYPE_SPARE: &'static [u8; 6usize] = b"spare\x00";
pub const VDEV_TYPE_LOG: &'static [u8; 4usize] = b"log\x00";
pub const VDEV_TYPE_L2CACHE: &'static [u8; 8usize] = b"l2cache\x00";
pub const ZFS_MAXPROPLEN: ::std::os::raw::c_uint = 4096;
pub const ZPOOL_MAXPROPLEN: ::std::os::raw::c_uint = 4096;
pub mod boolean {
    pub type Type = ::std::os::raw::c_uint;
    pub const B_FALSE: Type = 0;
    pub const B_TRUE: Type = 1;
}
pub use self::boolean::Type as boolean_t;
pub type longlong_t = ::std::os::raw::c_longlong;
pub type diskaddr_t = longlong_t;
pub type hrtime_t = ::std::os::raw::c_longlong;
pub const zfs_type_t_ZFS_TYPE_FILESYSTEM: zfs_type_t = zfs_type_t(1);
pub const zfs_type_t_ZFS_TYPE_SNAPSHOT: zfs_type_t = zfs_type_t(2);
pub const zfs_type_t_ZFS_TYPE_VOLUME: zfs_type_t = zfs_type_t(4);
pub const zfs_type_t_ZFS_TYPE_POOL: zfs_type_t = zfs_type_t(8);
pub const zfs_type_t_ZFS_TYPE_BOOKMARK: zfs_type_t = zfs_type_t(16);
impl ::std::ops::BitOr<zfs_type_t> for zfs_type_t {
    type
    Output
    =
    Self;
    #[inline]
    fn bitor(self, other: Self) -> Self { zfs_type_t(self.0 | other.0) }
}
impl ::std::ops::BitOrAssign for zfs_type_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: zfs_type_t) { self.0 |= rhs.0; }
}
impl ::std::ops::BitAnd<zfs_type_t> for zfs_type_t {
    type
    Output
    =
    Self;
    #[inline]
    fn bitand(self, other: Self) -> Self { zfs_type_t(self.0 & other.0) }
}
impl ::std::ops::BitAndAssign for zfs_type_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: zfs_type_t) { self.0 &= rhs.0; }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct zfs_type_t(pub ::std::os::raw::c_uint);
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum dmu_objset_type {
    DMU_OST_NONE = 0,
    DMU_OST_META = 1,
    DMU_OST_ZFS = 2,
    DMU_OST_ZVOL = 3,
    DMU_OST_OTHER = 4,
    DMU_OST_ANY = 5,
    DMU_OST_NUMTYPES = 6,
}
pub use self::dmu_objset_type as dmu_objset_type_t;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zfs_prop_t {
    ZFS_PROP_BAD = -1,
    ZFS_PROP_TYPE = 0,
    ZFS_PROP_CREATION = 1,
    ZFS_PROP_USED = 2,
    ZFS_PROP_AVAILABLE = 3,
    ZFS_PROP_REFERENCED = 4,
    ZFS_PROP_COMPRESSRATIO = 5,
    ZFS_PROP_MOUNTED = 6,
    ZFS_PROP_ORIGIN = 7,
    ZFS_PROP_QUOTA = 8,
    ZFS_PROP_RESERVATION = 9,
    ZFS_PROP_VOLSIZE = 10,
    ZFS_PROP_VOLBLOCKSIZE = 11,
    ZFS_PROP_RECORDSIZE = 12,
    ZFS_PROP_MOUNTPOINT = 13,
    ZFS_PROP_SHARENFS = 14,
    ZFS_PROP_CHECKSUM = 15,
    ZFS_PROP_COMPRESSION = 16,
    ZFS_PROP_ATIME = 17,
    ZFS_PROP_DEVICES = 18,
    ZFS_PROP_EXEC = 19,
    ZFS_PROP_SETUID = 20,
    ZFS_PROP_READONLY = 21,
    ZFS_PROP_ZONED = 22,
    ZFS_PROP_SNAPDIR = 23,
    ZFS_PROP_PRIVATE = 24,
    ZFS_PROP_ACLINHERIT = 25,
    ZFS_PROP_CREATETXG = 26,
    ZFS_PROP_NAME = 27,
    ZFS_PROP_CANMOUNT = 28,
    ZFS_PROP_ISCSIOPTIONS = 29,
    ZFS_PROP_XATTR = 30,
    ZFS_PROP_NUMCLONES = 31,
    ZFS_PROP_COPIES = 32,
    ZFS_PROP_VERSION = 33,
    ZFS_PROP_UTF8ONLY = 34,
    ZFS_PROP_NORMALIZE = 35,
    ZFS_PROP_CASE = 36,
    ZFS_PROP_VSCAN = 37,
    ZFS_PROP_NBMAND = 38,
    ZFS_PROP_SHARESMB = 39,
    ZFS_PROP_REFQUOTA = 40,
    ZFS_PROP_REFRESERVATION = 41,
    ZFS_PROP_GUID = 42,
    ZFS_PROP_PRIMARYCACHE = 43,
    ZFS_PROP_SECONDARYCACHE = 44,
    ZFS_PROP_USEDSNAP = 45,
    ZFS_PROP_USEDDS = 46,
    ZFS_PROP_USEDCHILD = 47,
    ZFS_PROP_USEDREFRESERV = 48,
    ZFS_PROP_USERACCOUNTING = 49,
    ZFS_PROP_STMF_SHAREINFO = 50,
    ZFS_PROP_DEFER_DESTROY = 51,
    ZFS_PROP_USERREFS = 52,
    ZFS_PROP_LOGBIAS = 53,
    ZFS_PROP_UNIQUE = 54,
    ZFS_PROP_OBJSETID = 55,
    ZFS_PROP_DEDUP = 56,
    ZFS_PROP_MLSLABEL = 57,
    ZFS_PROP_SYNC = 58,
    ZFS_PROP_DNODESIZE = 59,
    ZFS_PROP_REFRATIO = 60,
    ZFS_PROP_WRITTEN = 61,
    ZFS_PROP_CLONES = 62,
    ZFS_PROP_LOGICALUSED = 63,
    ZFS_PROP_LOGICALREFERENCED = 64,
    ZFS_PROP_INCONSISTENT = 65,
    ZFS_PROP_VOLMODE = 66,
    ZFS_PROP_FILESYSTEM_LIMIT = 67,
    ZFS_PROP_SNAPSHOT_LIMIT = 68,
    ZFS_PROP_FILESYSTEM_COUNT = 69,
    ZFS_PROP_SNAPSHOT_COUNT = 70,
    ZFS_PROP_SNAPDEV = 71,
    ZFS_PROP_ACLTYPE = 72,
    ZFS_PROP_SELINUX_CONTEXT = 73,
    ZFS_PROP_SELINUX_FSCONTEXT = 74,
    ZFS_PROP_SELINUX_DEFCONTEXT = 75,
    ZFS_PROP_SELINUX_ROOTCONTEXT = 76,
    ZFS_PROP_RELATIME = 77,
    ZFS_PROP_REDUNDANT_METADATA = 78,
    ZFS_PROP_OVERLAY = 79,
    ZFS_PROP_PREV_SNAP = 80,
    ZFS_PROP_RECEIVE_RESUME_TOKEN = 81,
    ZFS_NUM_PROPS = 82,
}
pub mod zpool_prop_t {
    pub type Type = ::std::os::raw::c_uint;
    pub const ZPOOL_PROP_NAME: Type = 0;
    pub const ZPOOL_PROP_SIZE: Type = 1;
    pub const ZPOOL_PROP_CAPACITY: Type = 2;
    pub const ZPOOL_PROP_ALTROOT: Type = 3;
    pub const ZPOOL_PROP_HEALTH: Type = 4;
    pub const ZPOOL_PROP_GUID: Type = 5;
    pub const ZPOOL_PROP_VERSION: Type = 6;
    pub const ZPOOL_PROP_BOOTFS: Type = 7;
    pub const ZPOOL_PROP_DELEGATION: Type = 8;
    pub const ZPOOL_PROP_AUTOREPLACE: Type = 9;
    pub const ZPOOL_PROP_CACHEFILE: Type = 10;
    pub const ZPOOL_PROP_FAILUREMODE: Type = 11;
    pub const ZPOOL_PROP_LISTSNAPS: Type = 12;
    pub const ZPOOL_PROP_AUTOEXPAND: Type = 13;
    pub const ZPOOL_PROP_DEDUPDITTO: Type = 14;
    pub const ZPOOL_PROP_DEDUPRATIO: Type = 15;
    pub const ZPOOL_PROP_FREE: Type = 16;
    pub const ZPOOL_PROP_ALLOCATED: Type = 17;
    pub const ZPOOL_PROP_READONLY: Type = 18;
    pub const ZPOOL_PROP_ASHIFT: Type = 19;
    pub const ZPOOL_PROP_COMMENT: Type = 20;
    pub const ZPOOL_PROP_EXPANDSZ: Type = 21;
    pub const ZPOOL_PROP_FREEING: Type = 22;
    pub const ZPOOL_PROP_FRAGMENTATION: Type = 23;
    pub const ZPOOL_PROP_LEAKED: Type = 24;
    pub const ZPOOL_PROP_MAXBLOCKSIZE: Type = 25;
    pub const ZPOOL_PROP_TNAME: Type = 26;
    pub const ZPOOL_PROP_MAXDNODESIZE: Type = 27;
    pub const ZPOOL_PROP_MULTIHOST: Type = 28;
    pub const ZPOOL_NUM_PROPS: Type = 29;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zprop_source_t {
    ZPROP_SRC_NONE = 1,
    ZPROP_SRC_DEFAULT = 2,
    ZPROP_SRC_TEMPORARY = 4,
    ZPROP_SRC_LOCAL = 8,
    ZPROP_SRC_INHERITED = 16,
    ZPROP_SRC_RECEIVED = 32,
}
extern "C" {
    pub fn zfs_prop_to_name(arg1: zfs_prop_t)
     -> *const ::std::os::raw::c_char;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum vdev_state {
    VDEV_STATE_UNKNOWN = 0,
    VDEV_STATE_CLOSED = 1,
    VDEV_STATE_OFFLINE = 2,
    VDEV_STATE_REMOVED = 3,
    VDEV_STATE_CANT_OPEN = 4,
    VDEV_STATE_FAULTED = 5,
    VDEV_STATE_DEGRADED = 6,
    VDEV_STATE_HEALTHY = 7,
}
pub use self::vdev_state as vdev_state_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum vdev_aux {
    VDEV_AUX_NONE = 0,
    VDEV_AUX_OPEN_FAILED = 1,
    VDEV_AUX_CORRUPT_DATA = 2,
    VDEV_AUX_NO_REPLICAS = 3,
    VDEV_AUX_BAD_GUID_SUM = 4,
    VDEV_AUX_TOO_SMALL = 5,
    VDEV_AUX_BAD_LABEL = 6,
    VDEV_AUX_VERSION_NEWER = 7,
    VDEV_AUX_VERSION_OLDER = 8,
    VDEV_AUX_UNSUP_FEAT = 9,
    VDEV_AUX_SPARED = 10,
    VDEV_AUX_ERR_EXCEEDED = 11,
    VDEV_AUX_IO_FAILURE = 12,
    VDEV_AUX_BAD_LOG = 13,
    VDEV_AUX_EXTERNAL = 14,
    VDEV_AUX_SPLIT_POOL = 15,
    VDEV_AUX_BAD_ASHIFT = 16,
    VDEV_AUX_EXTERNAL_PERSIST = 17,
    VDEV_AUX_ACTIVE = 18,
}
pub use self::vdev_aux as vdev_aux_t;
pub mod pool_state {
    pub type Type = ::std::os::raw::c_uint;
    pub const POOL_STATE_ACTIVE: Type = 0;
    pub const POOL_STATE_EXPORTED: Type = 1;
    pub const POOL_STATE_DESTROYED: Type = 2;
    pub const POOL_STATE_SPARE: Type = 3;
    pub const POOL_STATE_L2CACHE: Type = 4;
    pub const POOL_STATE_UNINITIALIZED: Type = 5;
    pub const POOL_STATE_UNAVAIL: Type = 6;
    pub const POOL_STATE_POTENTIALLY_ACTIVE: Type = 7;
}
pub use self::pool_state::Type as pool_state_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vdev_stat {
    pub vs_timestamp: hrtime_t,
    pub vs_state: u64,
    pub vs_aux: u64,
    pub vs_alloc: u64,
    pub vs_space: u64,
    pub vs_dspace: u64,
    pub vs_rsize: u64,
    pub vs_esize: u64,
    pub vs_ops: [u64; 6usize],
    pub vs_bytes: [u64; 6usize],
    pub vs_read_errors: u64,
    pub vs_write_errors: u64,
    pub vs_checksum_errors: u64,
    pub vs_self_healed: u64,
    pub vs_scan_removing: u64,
    pub vs_scan_processed: u64,
    pub vs_fragmentation: u64,
}
#[test]
fn bindgen_test_layout_vdev_stat() {
    assert_eq!(::std::mem::size_of::<vdev_stat>() , 216usize , concat ! (
               "Size of: " , stringify ! ( vdev_stat ) ));
    assert_eq! (::std::mem::align_of::<vdev_stat>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( vdev_stat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_timestamp as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_state as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_aux as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_aux ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_alloc as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_alloc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_space as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_space ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_dspace as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_dspace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_rsize as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_rsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_esize as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_esize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_ops as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_bytes as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_bytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_read_errors as * const
                _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_read_errors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_write_errors as *
                const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_write_errors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_checksum_errors as *
                const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_checksum_errors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_self_healed as * const
                _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_self_healed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_scan_removing as *
                const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_scan_removing ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_scan_processed as *
                const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_scan_processed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_fragmentation as *
                const _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_fragmentation ) ));
}
impl Clone for vdev_stat {
    fn clone(&self) -> Self { *self }
}
pub type vdev_stat_t = vdev_stat;
extern "C" {
    pub fn thread_init();
}
extern "C" {
    pub fn thread_fini();
}
#[repr(C)]
#[derive(Copy)]
pub struct dmu_objset_stats {
    pub dds_num_clones: u64,
    pub dds_creation_txg: u64,
    pub dds_guid: u64,
    pub dds_type: dmu_objset_type_t,
    pub dds_is_snapshot: u8,
    pub dds_inconsistent: u8,
    pub dds_origin: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_dmu_objset_stats() {
    assert_eq!(::std::mem::size_of::<dmu_objset_stats>() , 288usize , concat !
               ( "Size of: " , stringify ! ( dmu_objset_stats ) ));
    assert_eq! (::std::mem::align_of::<dmu_objset_stats>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( dmu_objset_stats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dmu_objset_stats ) ) . dds_num_clones as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( dmu_objset_stats ) ,
                "::" , stringify ! ( dds_num_clones ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dmu_objset_stats ) ) . dds_creation_txg
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( dmu_objset_stats ) ,
                "::" , stringify ! ( dds_creation_txg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dmu_objset_stats ) ) . dds_guid as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( dmu_objset_stats ) ,
                "::" , stringify ! ( dds_guid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dmu_objset_stats ) ) . dds_type as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( dmu_objset_stats ) ,
                "::" , stringify ! ( dds_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dmu_objset_stats ) ) . dds_is_snapshot as
                * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( dmu_objset_stats ) ,
                "::" , stringify ! ( dds_is_snapshot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dmu_objset_stats ) ) . dds_inconsistent
                as * const _ as usize } , 29usize , concat ! (
                "Alignment of field: " , stringify ! ( dmu_objset_stats ) ,
                "::" , stringify ! ( dds_inconsistent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dmu_objset_stats ) ) . dds_origin as *
                const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( dmu_objset_stats ) ,
                "::" , stringify ! ( dds_origin ) ));
}
impl Clone for dmu_objset_stats {
    fn clone(&self) -> Self { *self }
}
pub type dmu_objset_stats_t = dmu_objset_stats;
#[repr(C)]
#[derive(Copy)]
pub struct zfs_handle {
    pub zfs_hdl: *mut libzfs_handle_t,
    pub zpool_hdl: *mut zpool_handle_t,
    pub zfs_name: [::std::os::raw::c_char; 256usize],
    pub zfs_type: zfs_type_t,
    pub zfs_head_type: zfs_type_t,
    pub zfs_dmustats: dmu_objset_stats_t,
    pub zfs_props: *mut nvlist_t,
    pub zfs_user_props: *mut nvlist_t,
    pub zfs_recvd_props: *mut nvlist_t,
    pub zfs_mntcheck: boolean_t,
    pub zfs_mntopts: *mut ::std::os::raw::c_char,
    pub zfs_props_table: *mut u8,
}
#[test]
fn bindgen_test_layout_zfs_handle() {
    assert_eq!(::std::mem::size_of::<zfs_handle>() , 616usize , concat ! (
               "Size of: " , stringify ! ( zfs_handle ) ));
    assert_eq! (::std::mem::align_of::<zfs_handle>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( zfs_handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zfs_handle ) ) . zfs_hdl as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( zfs_handle ) , "::" ,
                stringify ! ( zfs_hdl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zfs_handle ) ) . zpool_hdl as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( zfs_handle ) , "::" ,
                stringify ! ( zpool_hdl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zfs_handle ) ) . zfs_name as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( zfs_handle ) , "::" ,
                stringify ! ( zfs_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zfs_handle ) ) . zfs_type as * const _ as
                usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( zfs_handle ) , "::" ,
                stringify ! ( zfs_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zfs_handle ) ) . zfs_head_type as * const
                _ as usize } , 276usize , concat ! (
                "Alignment of field: " , stringify ! ( zfs_handle ) , "::" ,
                stringify ! ( zfs_head_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zfs_handle ) ) . zfs_dmustats as * const
                _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( zfs_handle ) , "::" ,
                stringify ! ( zfs_dmustats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zfs_handle ) ) . zfs_props as * const _
                as usize } , 568usize , concat ! (
                "Alignment of field: " , stringify ! ( zfs_handle ) , "::" ,
                stringify ! ( zfs_props ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zfs_handle ) ) . zfs_user_props as *
                const _ as usize } , 576usize , concat ! (
                "Alignment of field: " , stringify ! ( zfs_handle ) , "::" ,
                stringify ! ( zfs_user_props ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zfs_handle ) ) . zfs_recvd_props as *
                const _ as usize } , 584usize , concat ! (
                "Alignment of field: " , stringify ! ( zfs_handle ) , "::" ,
                stringify ! ( zfs_recvd_props ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zfs_handle ) ) . zfs_mntcheck as * const
                _ as usize } , 592usize , concat ! (
                "Alignment of field: " , stringify ! ( zfs_handle ) , "::" ,
                stringify ! ( zfs_mntcheck ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zfs_handle ) ) . zfs_mntopts as * const _
                as usize } , 600usize , concat ! (
                "Alignment of field: " , stringify ! ( zfs_handle ) , "::" ,
                stringify ! ( zfs_mntopts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zfs_handle ) ) . zfs_props_table as *
                const _ as usize } , 608usize , concat ! (
                "Alignment of field: " , stringify ! ( zfs_handle ) , "::" ,
                stringify ! ( zfs_props_table ) ));
}
impl Clone for zfs_handle {
    fn clone(&self) -> Self { *self }
}
pub type zfs_handle_t = zfs_handle;
#[repr(C)]
#[derive(Copy)]
pub struct zpool_handle {
    pub zpool_hdl: *mut libzfs_handle_t,
    pub zpool_next: *mut zpool_handle_t,
    pub zpool_name: [::std::os::raw::c_char; 256usize],
    pub zpool_state: ::std::os::raw::c_int,
    pub zpool_config_size: usize,
    pub zpool_config: *mut nvlist_t,
    pub zpool_old_config: *mut nvlist_t,
    pub zpool_props: *mut nvlist_t,
    pub zpool_start_block: diskaddr_t,
}
#[test]
fn bindgen_test_layout_zpool_handle() {
    assert_eq!(::std::mem::size_of::<zpool_handle>() , 320usize , concat ! (
               "Size of: " , stringify ! ( zpool_handle ) ));
    assert_eq! (::std::mem::align_of::<zpool_handle>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( zpool_handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zpool_handle ) ) . zpool_hdl as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( zpool_handle ) , "::" ,
                stringify ! ( zpool_hdl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zpool_handle ) ) . zpool_next as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( zpool_handle ) , "::" ,
                stringify ! ( zpool_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zpool_handle ) ) . zpool_name as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( zpool_handle ) , "::" ,
                stringify ! ( zpool_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zpool_handle ) ) . zpool_state as * const
                _ as usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( zpool_handle ) , "::" ,
                stringify ! ( zpool_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zpool_handle ) ) . zpool_config_size as *
                const _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( zpool_handle ) , "::" ,
                stringify ! ( zpool_config_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zpool_handle ) ) . zpool_config as *
                const _ as usize } , 288usize , concat ! (
                "Alignment of field: " , stringify ! ( zpool_handle ) , "::" ,
                stringify ! ( zpool_config ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zpool_handle ) ) . zpool_old_config as *
                const _ as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! ( zpool_handle ) , "::" ,
                stringify ! ( zpool_old_config ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zpool_handle ) ) . zpool_props as * const
                _ as usize } , 304usize , concat ! (
                "Alignment of field: " , stringify ! ( zpool_handle ) , "::" ,
                stringify ! ( zpool_props ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zpool_handle ) ) . zpool_start_block as *
                const _ as usize } , 312usize , concat ! (
                "Alignment of field: " , stringify ! ( zpool_handle ) , "::" ,
                stringify ! ( zpool_start_block ) ));
}
impl Clone for zpool_handle {
    fn clone(&self) -> Self { *self }
}
pub type zpool_handle_t = zpool_handle;
pub type libzfs_handle_t = [u64; 305usize];
extern "C" {
    pub fn libzfs_init() -> *mut libzfs_handle_t;
}
extern "C" {
    pub fn libzfs_fini(arg1: *mut libzfs_handle_t);
}
extern "C" {
    pub fn zpool_get_handle(arg1: *mut zpool_handle_t)
     -> *mut libzfs_handle_t;
}
extern "C" {
    pub fn libzfs_error_description(arg1: *mut libzfs_handle_t)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn zpool_open_canfail(arg1: *mut libzfs_handle_t,
                              arg2: *const ::std::os::raw::c_char)
     -> *mut zpool_handle_t;
}
extern "C" {
    pub fn zpool_close(arg1: *mut zpool_handle_t);
}
extern "C" {
    pub fn zpool_get_name(arg1: *mut zpool_handle_t)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn zpool_get_state(arg1: *mut zpool_handle_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zpool_state_to_name(arg1: vdev_state_t, arg2: vdev_aux_t)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn zpool_pool_state_to_name(arg1: pool_state_t)
     -> *const ::std::os::raw::c_char;
}
pub type zpool_iter_f =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut zpool_handle_t,
                                               arg2:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn zpool_iter(arg1: *mut libzfs_handle_t, arg2: zpool_iter_f,
                      arg3: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zpool_get_prop(arg1: *mut zpool_handle_t, arg2: zpool_prop_t::Type,
                          arg3: *mut ::std::os::raw::c_char, proplen: usize,
                          arg4: *mut zprop_source_t, literal: boolean_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zpool_get_prop_int(arg1: *mut zpool_handle_t,
                              arg2: zpool_prop_t::Type,
                              arg3: *mut zprop_source_t) -> u64;
}
extern "C" {
    pub fn zpool_get_config(arg1: *mut zpool_handle_t,
                            arg2: *mut *mut nvlist_t) -> *mut nvlist_t;
}
extern "C" {
    pub fn zpool_export(arg1: *mut zpool_handle_t, arg2: boolean_t,
                        arg3: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zpool_import(arg1: *mut libzfs_handle_t, arg2: *mut nvlist_t,
                        arg3: *const ::std::os::raw::c_char,
                        altroot: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zpool_find_import(arg1: *mut libzfs_handle_t,
                             arg2: ::std::os::raw::c_int,
                             arg3: *mut *mut ::std::os::raw::c_char)
     -> *mut nvlist_t;
}
extern "C" {
    pub fn zfs_open(arg1: *mut libzfs_handle_t,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: ::std::os::raw::c_int) -> *mut zfs_handle_t;
}
extern "C" {
    pub fn zfs_close(arg1: *mut zfs_handle_t);
}
extern "C" {
    pub fn zfs_get_type(arg1: *const zfs_handle_t) -> zfs_type_t;
}
extern "C" {
    pub fn zfs_get_name(arg1: *const zfs_handle_t)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn zfs_prop_get(arg1: *mut zfs_handle_t, arg2: zfs_prop_t,
                        arg3: *mut ::std::os::raw::c_char, arg4: usize,
                        arg5: *mut zprop_source_t,
                        arg6: *mut ::std::os::raw::c_char, arg7: usize,
                        arg8: boolean_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zfs_get_user_props(arg1: *mut zfs_handle_t) -> *mut nvlist_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct zprop_list {
    pub pl_prop: ::std::os::raw::c_int,
    pub pl_user_prop: *mut ::std::os::raw::c_char,
    pub pl_next: *mut zprop_list,
    pub pl_all: boolean_t,
    pub pl_width: usize,
    pub pl_recvd_width: usize,
    pub pl_fixed: boolean_t,
}
#[test]
fn bindgen_test_layout_zprop_list() {
    assert_eq!(::std::mem::size_of::<zprop_list>() , 56usize , concat ! (
               "Size of: " , stringify ! ( zprop_list ) ));
    assert_eq! (::std::mem::align_of::<zprop_list>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( zprop_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zprop_list ) ) . pl_prop as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( zprop_list ) , "::" ,
                stringify ! ( pl_prop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zprop_list ) ) . pl_user_prop as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( zprop_list ) , "::" ,
                stringify ! ( pl_user_prop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zprop_list ) ) . pl_next as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( zprop_list ) , "::" ,
                stringify ! ( pl_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zprop_list ) ) . pl_all as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( zprop_list ) , "::" ,
                stringify ! ( pl_all ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zprop_list ) ) . pl_width as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( zprop_list ) , "::" ,
                stringify ! ( pl_width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zprop_list ) ) . pl_recvd_width as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( zprop_list ) , "::" ,
                stringify ! ( pl_recvd_width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zprop_list ) ) . pl_fixed as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( zprop_list ) , "::" ,
                stringify ! ( pl_fixed ) ));
}
impl Clone for zprop_list {
    fn clone(&self) -> Self { *self }
}
pub type zprop_list_t = zprop_list;
extern "C" {
    pub fn zfs_expand_proplist(arg1: *mut zfs_handle_t,
                               arg2: *mut *mut zprop_list_t, arg3: boolean_t,
                               arg4: boolean_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zprop_free_list(arg1: *mut zprop_list_t);
}
pub type zfs_iter_f =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut zfs_handle_t,
                                               arg2:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn zfs_iter_filesystems(arg1: *mut zfs_handle_t, arg2: zfs_iter_f,
                                arg3: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zfs_type_to_name(arg1: zfs_type_t)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn zfs_path_to_zhandle(arg1: *mut libzfs_handle_t,
                               arg2: *mut ::std::os::raw::c_char,
                               arg3: zfs_type_t) -> *mut zfs_handle_t;
}
extern "C" {
    pub fn zpool_disable_datasets(arg1: *mut zpool_handle_t, arg2: boolean_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zfs_validate_name(hdl: *mut libzfs_handle_t,
                             path: *const ::std::os::raw::c_char,
                             type_: ::std::os::raw::c_int,
                             modifying: boolean_t) -> ::std::os::raw::c_int;
}
